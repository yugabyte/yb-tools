# cat .bash_functions
# change ticket
ct() {
    if [[ $# -eq 0 ]] ; then
        echo 'ct <ticket-number>'
    else
        cd /cases/$1
fi
}

# troubleshoot transaction conflicts
function get_transaction_conflict_rca() {
    if [ $# -ne 2 ]; then
        echo "Usage: get_transaction_conflict_rca <higher_priority_transaction_uuid> <lower_priority_transaction_uuid>"
        return 1
    fi
    higher_priority_transaction_uuid=$1
    lower_priority_transaction_uuid=$2

    not_found_error="Make sure you have provided \n - the correct transaction UUID \n - have enabled the required logs \n - have unzipped the logs. This function requires the logs to be in plain text format."
    
    # Get higher priority transaction details
    echo -n "Finding session ID of higher priority transaction... "
    higher_priority_session_id=$(grep "$higher_priority_transaction_uuid" -r |grep 'Session id' |grep -i 'session id [0-9]\+' -o |head -n 1)
    if [ -z "$higher_priority_session_id" ]; then
        echo -e "Higher priority transaction not found\n$not_found_error"
        return 1
    fi
    echo "found : $higher_priority_session_id"
    echo -n "Finding backend PID of higher priority transaction... "
    higher_priority_backend_pid=$(grep "$higher_priority_session_id" -r |grep -i 'backend pid: [0-9]\+' -o |sed 's/backend pid: //g' |head -n 1)
    if [ -z "$higher_priority_backend_pid" ]; then
        echo -e "Higher priority backend PID not found\n$not_found_error"
        return 1
    fi
    echo "found backend PID: $higher_priority_backend_pid"

    # Get lower priority transaction details
    echo -n "Finding session ID of lower priority transaction... "
    lower_priority_session_id=$(grep "$lower_priority_transaction_uuid" -r |grep 'Session id' |grep -i 'session id [0-9]\+' -o |head -n 1)
    if [ -z "$lower_priority_session_id" ]; then
        echo -e "Lower priority transaction not found\n$not_found_error"
        return 1
    fi
    echo "found : $lower_priority_session_id"
    echo -n "Finding backend PID of lower priority transaction... "
    lower_priority_backend_pid=$(grep "$lower_priority_session_id" -r |grep -i 'backend pid: [0-9]\+' -o |sed 's/backend pid: //g' |head -n 1)
    if [ -z "$lower_priority_backend_pid" ]; then
        echo -e "Lower priority backend PID not found\n$not_found_error"
        return 1
    fi
    echo "found backend PID: $lower_priority_backend_pid"
    
    # Get higher priority transaction history
    datetime=$(date +"%Y-%m-%d_%H%M%S")
    grep "$higher_priority_backend_pid" -r > /tmp/higher_priority_transaction_history_$datetime.log
    # Get lower priority transaction history
    grep "$lower_priority_backend_pid" -r > /tmp/lower_priority_transaction_history_$datetime.log
    mv /tmp/higher_priority_transaction_history_$datetime.log .
    mv /tmp/lower_priority_transaction_history_$datetime.log .
    echo "Transaction history saved to higher_priority_transaction_history_$datetime.log and lower_priority_transaction_history_$datetime.log"
}

# Get the leader change time
function get_master_leader_change_time() {
    # Add help message
    if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
        echo "Run this function in the directory which contains the node directories"
    else
        find . -name "*master*INFO*" | while read -r file;
          do
            node=$(echo $file | cut -d'/' -f2)
            for time in $(zgrep "This master's current role is: LEADER" $file | cut -d' ' -f1,2| sed 's/ /-/g');
              do
                echo "$node $time" > /tmp/master_leader_change_time
              done
            done
        sort -k2 /tmp/master_leader_change_time | tee master_leader_change_time
        echo "Leader change time saved in master_leader_change_time file"
        rm /tmp/master_leader_change_time
    fi
}


# Get the tablet leader change time
function get_tablet_leader_change_time() {
    # Add help message
    if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
        echo "Run this function in the directory which contains the node directories"
        echo "USAGE: get_tablet_leader_change_time <tablet-id>"
    elif [[ $# -eq 0 ]]; then
        echo "Please provide the tablet id"
    else
        tablet_id=$1
        find . -name "*tserver*INFO*" | while read -r file;
          do
            node=$(echo $file | cut -d'/' -f2)
            for time in $(zgrep "T $tablet_id .*Updating active role from FOLLOWER to LEADER" $file | cut -d' ' -f1,2| sed 's/ /-/g');
              do
                echo "$node $time $file" >> /tmp/tablet_leader_change_time
              done
            done
        sort -k2 /tmp/tablet_leader_change_time | tee tablet_leader_change_time
        echo "Leader change time saved in tablet_leader_change_time file"
        rm /tmp/tablet_leader_change_time
    fi
}

# Get count of pattern per minute
get_count_per_minute() {
    # Add help message
    if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
        echo "USAGE: Use this function to get the count of a pattern per minute against the standard output"
        echo "Example: grep -r 'pattern' . | get_count_per_minute"
    else
        awk '{
            match($0, /[WIFE]([0-9]{4}) ([0-9]{2}:[0-9]{2})/, ts);
            if (ts[1] != "" && ts[2] != "") {
                timestamp = ts[1] " " ts[2];
                count[timestamp]++;
            }
        }
        END {
            for (time in count) {
                print time, count[time];
            }
        }' | sort
    fi
}

# Get the node information
get_node_info() {
# ------------------------------------------------------------------------------
# get_node_info
#
# This function retrieves node information from the log files of a YugabyteDB cluster.
# It extracts the following details:
# - Nodename
# - Type (master or tserver)
# - Hostname
# - RPC IP
# - Webserver IP
# - UUID
#
# The output is saved in a file named node_info.txt in the current directory.
# The function assumes that the log files are located in directories named with a prefix 'yb'.
# The output is formatted in a table for better readability.
# ------------------------------------------------------------------------------
    if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
        echo "Run this function in the directory which contains the node directories"
    fi
    tempfile=$(mktemp)
    echo "Nodename|Type|Hostname|RPC IP|Webserver IP|UUID" > $tempfile
    for d in $(ls -d yb*); do
        for type in master tserver; do
            log_file="$d/$type/logs/*INFO*"
            if grep -q 'Node information.*' $log_file 2>/dev/null; then
                node_info=$(grep -Eoh 'Node information.*' $log_file | head -n 1)
                hostname=$(echo $node_info | sed "s/.*hostname: '//g" | sed "s/', rpc_ip:.*//g")
                rpc_ip=$(echo $node_info | sed "s/.*rpc_ip: '//g" | sed "s/', webserver_ip:.*//g")
                webserver_ip=$(echo $node_info | sed "s/.*webserver_ip: '//g" | sed "s/', uuid:.*//g")
                uuid=$(echo $node_info | sed "s/.*uuid: '//g" | sed "s/' }.*//g")
                echo "$d | $type | $hostname | $rpc_ip | $webserver_ip | $uuid" >> $tempfile
            fi
        done
    done
    column -t -s '|' $tempfile | tee node_info.txt
    rm $tempfile
}

# Run lnav command
function run_lnav() {
    local script_path="/home/support/yogesh/scripts/run_lnav_command.py"
    local from_time=""
    local to_time=""
    local duration=""
    local context_time=""
    local after_time=""
    local before_time=""
    local types=""
    local nodes=""
    local rebuild=""
    local debug=""
    local help=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--from_time) from_time="$2"; shift 2;;
            -T|--to_time) to_time="$2"; shift 2;;
            -d|--duration) duration="$2"; shift 2;;
            -c|--context_time) context_time="$2"; shift 2;;
            -A|--after_time) after_time="$2"; shift 2;;
            -B|--before_time) before_time="$2"; shift 2;;
            --types) types="$2"; shift 2;;
            --nodes) nodes="$2"; shift 2;;
            --rebuild) rebuild="--rebuild"; shift;;
            --debug) debug="--debug"; shift;;
            -h|--help) help="-h"; shift;;
            *) echo "Unknown option: $1"; return 1;;
        esac
    done
    
    python3 $script_path \
        ${from_time:+-t "$from_time"} \
        ${to_time:+-T "$to_time"} \
        ${duration:+-d "$duration"} \
        ${context_time:+-c "$context_time"} \
        ${after_time:+-A "$after_time"} \
        ${before_time:+-B "$before_time"} \
        ${types:+--types "$types"} \
        ${nodes:+--nodes "$nodes"} \
        $rebuild \
        $debug \
        $help
}

# Get tablet consensus state change
get_tablet_consensus_state_change() {
  # ------------------------------------------------------------------------------
  # get_tablet_consensus_state_change <tablet_uuid> <logfile1> [logfile2 ...]
  #
  # Parses YugabyteDB master logs for consensus state changes for a specific tablet.
  #
  # Features:
  # - Filters log lines for the given tablet UUID.
  # - Supports multiple log files.
  # - Extracts:
  #     - Timestamp (MM-DD HH:MM:SS from log prefix)
  #     - Consensus term
  #     - Leader UUID (used to sort peers)
  #     - Config JSON (peer uuid + host, leader peer listed first)
  # - Displays results in a table using Python's `tabulate` module.
  # - Outputs valid JSON for config_json column.
  #
  # Intelligent Processing:
  # - Deduplicates entries per term, keeping only the latest by full timestamp as multiple peers can report the state change.
  # - Detects and reports missing terms in the consensus history (e.g., skipped term 7).
  # - Handles malformed lines gracefully without breaking.
  #
  # Notes:
  # - Requires Python 3 and `tabulate` (`pip install tabulate`)
  # - Output is sorted in descending timestamp order for easy inspection.
  # - Helpful for debugging leader elections, instability.
  # ------------------------------------------------------------------------------
  local tablet_uuid="$1"
  shift
  local files=("$@")

  if [[ -z "$tablet_uuid" || ${#files[@]} -eq 0 ]]; then
    echo "Usage: get_tablet_consensus_state_change <tablet_uuid> <logfile1> [logfile2 ...]"
    return 1
  fi

  grep "Tablet: $tablet_uuid reported consensus state change" "${files[@]}" | \
  python3 -c "
import sys
import re
import json
from datetime import datetime
from tabulate import tabulate

lines = sys.stdin.readlines()
entries = []

for line in lines:
    try:
        # Extract full timestamp (MMDD + HH:MM:SS.microseconds)
        ts_match = re.search(r'I(\d{4}) (\d{2}:\d{2}:\d{2}\.\d+)', line)
        if not ts_match:
            continue
        mmdd = ts_match.group(1)
        time_part = ts_match.group(2)
        month, day = int(mmdd[:2]), int(mmdd[2:])
        now = datetime.now()
        year = now.year  # assume logs are from the current year
        full_ts_str = f'{year}-{month:02d}-{day:02d} {time_part}'
        full_ts = datetime.strptime(full_ts_str, '%Y-%m-%d %H:%M:%S.%f')

        # Extract consensus term
        current_term = re.search(r'current_term: (\d+)', line).group(1)

        # Extract leader UUID
        leader_uuid = re.search(r'leader_uuid: \"([^\"]+)\"', line).group(1)

        # Extract peer UUIDs and hosts
        peer_pattern = re.compile(
            r'permanent_uuid: \"([^\"]+)\".*?host: \"([^\"]+)\"',
            re.DOTALL)
        peers = []
        for uuid, host in peer_pattern.findall(line):
            peers.append({\"uuid\": uuid, \"host\": host})

        # Move leader to the beginning of the peer list
        peers.sort(key=lambda p: 0 if p['uuid'] == leader_uuid else 1)

        entries.append({
            \"timestamp\": full_ts,                                # for deduplication and sorting
            \"display_ts\": full_ts.strftime('%m-%d %H:%M:%S'),    # user-friendly timestamp
            \"term\": current_term,
            \"config_json\": peers
        })

    except Exception:
        continue  # skip lines that can't be parsed

# Dedupe: keep only the latest report per term
# Reason: multiple followers can report the same leader election around the same time,
#         resulting in duplicate entries for the same term. We retain only the most
#         recent (latest timestamp) report for each term to reflect the final consensus
#         state seen by the master for that term.
latest_by_term = {}
for e in entries:
    term = e['term']
    if term not in latest_by_term or e['timestamp'] > latest_by_term[term]['timestamp']:
        latest_by_term[term] = e

# Sort deduplicated entries in descending timestamp order
deduped = list(latest_by_term.values())
deduped.sort(key=lambda x: x['timestamp'], reverse=True)

# Print the main table
print(tabulate(
    [(e['display_ts'], e['term'], json.dumps(e['config_json'], ensure_ascii=False)) for e in deduped],
    headers=[\"Time\", \"Term\", \"config_json (first is leader)\"],
    tablefmt=\"github\"
))

# Detect and print missing terms
observed_terms = sorted(int(e['term']) for e in deduped)
if observed_terms:
    expected_terms = set(range(min(observed_terms), max(observed_terms) + 1))
    missing_terms = sorted(expected_terms - set(observed_terms))
    if missing_terms:
        print(f\"\\n⚠️  Missing term(s): {', '.join(str(t) for t in missing_terms)}\\n\")
        print(\"Note: Missing terms could be due to master logs not being available when leader election for these terms happened.\")
        print(\"Ensure you are checking the logs of all N masters, where N is the replication factor.\")
"
}